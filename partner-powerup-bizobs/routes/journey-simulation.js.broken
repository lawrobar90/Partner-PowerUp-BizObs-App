import express from 'express';
import http from 'http';
import { randomBytes } from 'crypto';
import { ensureServiceRunning, getServicePort, getServiceNameFromStep } from '../services/service-manager.js';

const router = express.Router();

// Default     const journeyComplete = {
      journeyId,
      customerId,
      correlationId,
      status: 'completed',
      totalSteps: stepData.length,
      completedSteps: journeyResults.filter(r => r.status !== 'failed').length,
      totalDuration: journeyResults.reduce((sum, step) => sum + (step.processingTime || 0), 0),
      stepNames: stepData.map(s => s.stepName),urney structure (can be overridden by generated journey)
const DEFAULT_JOURNEY_STEPS = [
  'Discovery',
  'Awareness', 
  'Consideration',
  'Purchase',
  'Retention',
  'Advocacy'
];

// Call a dynamic service
async function callDynamicService(stepName, port, payload, headers = {}) {
  return new Promise((resolve, reject) => {
    const traceparent = headers.traceparent || `00-${randomBytes(16).toString('hex')}-${randomBytes(8).toString('hex')}-01`;
    const options = {
      hostname: '127.0.0.1',
      port: port,
      path: '/process',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        traceparent,
        'x-correlation-id': headers['x-correlation-id'] || payload.correlationId || `cid_${Date.now()}`,
        'x-journey-id': payload.journeyId || '',
        'x-journey-step': payload.stepName || stepName || '',
        'x-customer-segment': payload.domain || ''
      }
    };
    
    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        try {
          const response = JSON.parse(body);
          resolve(response);
        } catch (e) {
          reject(new Error(`Invalid JSON from ${stepName}Service: ${body}`));
        }
      });
    });
    
    req.on('error', reject);
    req.write(JSON.stringify(payload));
    req.end();
  });
}

// Complete 6-step customer journey simulation with dynamic service naming
router.post('/simulate-journey', async (req, res) => {
  try {
    const { 
      journeyId = `journey_${Date.now()}`, 
      customerId = `customer_${Date.now()}`,
      journeyData,
      stepNames: stepNamesInBody,
      chained = true,
      thinkTimeMs = 250
    } = req.body || {};
    
    const correlationId = req.correlationId;
    
    console.log(`[journey-sim] Starting 6-step journey simulation: ${journeyId}`);
    
    // Determine the 6 step names and service names from the request or journey data or use defaults
    let stepNames = DEFAULT_JOURNEY_STEPS;
    let stepData = []; // Will store both stepName and serviceName for each step
    
    console.log('[journey-sim] Request body stepNames:', req.body.stepNames);
    console.log('[journey-sim] Request body aiJourney:', req.body.aiJourney ? 'present' : 'not present');
    console.log('[journey-sim] Journey data:', journeyData ? Object.keys(journeyData) : 'no journey data');
    
    // Check aiJourney structure first (from UI)
    if (req.body.aiJourney?.steps && Array.isArray(req.body.aiJourney.steps)) {
      stepData = req.body.aiJourney.steps.slice(0, 6).map(step => ({
        stepName: step.name || step.stepName || 'UnknownStep',
        serviceName: step.serviceName || null
      }));
      stepNames = stepData.map(s => s.stepName);
      console.log('[journey-sim] Using aiJourney.steps:', stepData);
    }
    // Check direct stepNames array
    else if (stepNamesInBody && Array.isArray(stepNamesInBody) && stepNamesInBody.length >= 6) {
      stepNames = stepNamesInBody.slice(0, 6);
      stepData = stepNames.map(name => ({ stepName: name, serviceName: null }));
      console.log('[journey-sim] Using request stepNames:', stepNames);
    }
    // Check nested journey structures
    else if (journeyData?.journey?.steps && Array.isArray(journeyData.journey.steps)) {
      const steps = journeyData.journey.steps.slice(0, 6);
      stepData = steps.map(step => ({
        stepName: step.stepName || step.name || 'UnknownStep',
        serviceName: step.serviceName || null
      }));
      // Fill with defaults if needed
      while (stepData.length < 6) {
        stepData.push({ stepName: DEFAULT_JOURNEY_STEPS[stepData.length], serviceName: null });
      }
      stepNames = stepData.map(s => s.stepName);
      console.log('[journey-sim] Using journey.steps:', stepData);
    }
    else if (journeyData?.steps && Array.isArray(journeyData.steps)) {
      const steps = journeyData.steps.slice(0, 6);
      stepData = steps.map(step => ({
        stepName: step.stepName || step.name || 'UnknownStep',
        serviceName: step.serviceName || null
      }));
      // Fill with defaults if needed
      while (stepData.length < 6) {
        stepData.push({ stepName: DEFAULT_JOURNEY_STEPS[stepData.length], serviceName: null });
      }
      stepNames = stepData.map(s => s.stepName);
      console.log('[journey-sim] Using steps:', stepData);
    } else {
      stepData = DEFAULT_JOURNEY_STEPS.map(name => ({ stepName: name, serviceName: null }));
      console.log('[journey-sim] Using default stepNames:', stepNames);
    }
    
    console.log(`[journey-sim] Using step names: ${JSON.stringify(stepNames)}`);
    
    // Initialize currentPayload early for company context
    let currentPayload = {
      journeyId,
      customerId,
      correlationId,
      startTime: new Date().toISOString(),
      // Extract company context for service tagging - prioritize direct request body over nested structures
      companyName: req.body.companyName || (req.body.aiJourney && req.body.aiJourney.companyName) || (journeyData && journeyData.companyName) || 'DefaultCompany',
      domain: req.body.domain || (req.body.aiJourney && req.body.aiJourney.domain) || (journeyData && journeyData.domain) || 'default.com',
      industryType: req.body.industryType || (req.body.aiJourney && req.body.aiJourney.industryType) || (journeyData && journeyData.industryType) || 'general'
    };
    
    // Ensure all services are running (we'll still only call the first in chained mode)
    console.log('[journey-sim] Ensuring all 6 dynamic services are running...');
    const companyContext = {
      companyName: currentPayload.companyName,
      domain: currentPayload.domain,
      industryType: currentPayload.industryType
    };
    
    for (let i = 0; i < stepData.length; i++) {
      const { stepName, serviceName } = stepData[i];
      // Add stepName to companyContext for per-step env tagging
      // Pass serviceName if available so service-manager can use exact name
      ensureServiceRunning(stepName, { ...companyContext, stepName, serviceName });
    }
    // Wait briefly for services to bind
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const journeyResults = [];
    
  if (chained) {
      // CHAINED MODE: call only the first service; it will invoke the rest in order
      const first = stepNames[0];
      const firstPort = getServicePort(first);
      const firstService = getServiceNameFromStep(first);
      console.log(`[journey-sim] [chained] Calling first service ${firstService} on port ${firstPort}`);

      const payload = {
        ...currentPayload,
        stepName: first,
        thinkTimeMs,
        steps: stepData.map(s => ({ stepName: s.stepName, serviceName: s.serviceName }))
      };
      const chainedResult = await callDynamicService(first, firstPort, payload, { 'x-correlation-id': correlationId });
      
      // Flatten chained results for better reporting
      const flattenChainedResults = (result, stepNumber = 1) => {
        const flattened = [{ 
          ...result, 
          stepNumber, 
          serviceName: result.service || getServiceNameFromStep(result.stepName || 'Unknown'),
          // Remove the nested 'next' to avoid circular references in the final response
          next: undefined
        }];
        if (result.next) {
          flattened.push(...flattenChainedResults(result.next, stepNumber + 1));
        }
        return flattened;
      };
      
      journeyResults.push(...flattenChainedResults(chainedResult));
    } else {
      // NON-CHAINED MODE: execute all steps from the main server sequentially
      let lastTraceparent = null;
      let lastTracestate = null;
      let lastCorrelationId = correlationId;
      for (let i = 0; i < stepData.length; i++) {
        const { stepName, serviceName: payloadServiceName } = stepData[i];
        // Use exact serviceName from payload if provided, otherwise auto-generate
        const serviceName = payloadServiceName || getServiceNameFromStep(stepName);
        const servicePort = getServicePort(stepName);
        console.log(`[journey-sim] Step ${i + 1}/${stepData.length}: Calling ${serviceName} on port ${servicePort}`);
        try {
          // Propagate trace context from previous step
          const headers = {
            'x-correlation-id': lastCorrelationId
          };
          if (lastTraceparent) headers.traceparent = lastTraceparent;
          if (lastTracestate) headers.tracestate = lastTracestate;
          const stepResult = await callDynamicService(stepName, servicePort, {
            ...currentPayload,
            stepName,
            stepIndex: i + 1,
            totalSteps: stepData.length,
            thinkTimeMs,
            previousStep: i > 0 ? journeyResults[i - 1] : null
          }, headers);
          journeyResults.push({
            ...stepResult,
            stepNumber: i + 1,
            stepName,
            serviceName
          });
          // Pass trace context to next step
          lastTraceparent = stepResult.traceparent || lastTraceparent;
          lastTracestate = stepResult.tracestate || lastTracestate;
          lastCorrelationId = stepResult.correlationId || lastCorrelationId;
          // Pass accumulated data to next step
          currentPayload = {
            ...currentPayload,
            previousStepResult: stepResult,
            accumulatedData: {
              ...currentPayload.accumulatedData,
              [`step_${i + 1}`]: stepResult.metadata
            }
          };
          console.log(`[journey-sim] âœ… Step ${i + 1}/${stepData.length} completed: ${serviceName}`);
        } catch (error) {
          console.error(`[journey-sim] âŒ Step ${i + 1}/${stepData.length} failed: ${error.message}`);
          journeyResults.push({
            stepNumber: i + 1,
            stepName,
            serviceName,
            status: 'failed',
            error: error.message,
            timestamp: new Date().toISOString()
          });
        }
        // Add small delay between steps to simulate realistic user behavior
        await new Promise(resolve => setTimeout(resolve, thinkTimeMs));
      }
    }
    
    const journeyComplete = {
      journeyId,
      customerId,
      correlationId,
      status: 'completed',
      totalSteps: 6,
      completedSteps: journeyResults.filter(r => r.status === 'completed').length,
      totalDuration: journeyResults.reduce((sum, r) => sum + (r.processingTime || 0), 0),
      stepNames,
      steps: journeyResults,
      completedAt: new Date().toISOString()
    };
    
  console.log(`[journey-sim] ðŸŽ‰ Journey ${journeyId} completed: ${journeyComplete.completedSteps}/6 successful steps (chained=${!!chained})`);
    
    res.json({
      success: true,
      journey: journeyComplete
    });
    
  } catch (error) {
    console.error('[journey-sim] Journey simulation failed:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get status of all dynamic services
router.get('/status', async (req, res) => {
  try {
    // Get list of currently running services from health endpoint
    const healthRes = await fetch('http://localhost:4000/api/health');
    const healthData = await healthRes.json();
    
    res.json({
      totalExpectedServices: 6,
      runningServices: healthData.childServices?.length || 0,
      services: healthData.childServices || []
    });
  } catch (error) {
    res.status(500).json({
      error: 'Failed to get service status',
      message: error.message
    });
  }
});

export default router;